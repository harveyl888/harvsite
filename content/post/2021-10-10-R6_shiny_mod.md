+++
author = "Harvey"
title = "Connecting shiny modules through R6"
date = "2021-10-10"
description = "Using an R6 class to share data between multiple shiny modules"
tags = ["R", "shiny", "Shiny modules"]
codeMaxLines = 30
draft = true
+++

## Introduction

Here's a simple example of working with a reactive R6 in a shiny app.  It is inspired by a post to RStudio Community (https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) and uses the code provided by Winston Chang to create an R6 class that is reactive.  I can see two advantages and one disadvantage to using a reactive R6 class in a shiny app.

### Advantages

-  A single class instance can be shared between all shiny modules.  This is particularly useful when working with shiny modules that are interdependent - ie content in module A is dependent on modules B and C, content in module B is dependent on modules A and C and content in module C is dependent on modules A and B.  Using a reactive class means that we would simply send the class instance to each module.  Any changes made to the class would automatically update in all shiny modules.
-  The R6 class instance itself can be saved and read back in at a later date, essentially providing a snapshot.  Saving and reimporting the class instance is a great way to keep a set of complex data together.

### Disadvantage

-  Since updating the class triggers a refresh, some reactive outputs may be updated when their content has not changed.  This is due to the class itself being reactive.

In this post I'll demonstrate a reactive R6 class called `Analysis` using a simple PCA and clustering example.

## The Reactive Class
The main part of the code is the reactive class.  Our class is built up from the code in the [RStudio Community article](https://community.rstudio.com/t/good-way-to-create-a-reactive-aware-r6-class/84890) when the class is initialized as reactive using `Analysis$new(data=mydata)$reactive()` (chaining), or by running the `reactive()` method on an initialized class instance, a couple of things occur:

-  a reactiveVal, `reactiveDep` is created, linked to a counter, which increases when the private `invalidate()` method is called.
-  a reactive expression, `reactiveExpr` is created which updates when `reactiveDep` changes.

The skeleton for the reactive R6 class is shown below:

```r
Analysis <- R6Class("Analysis",
                               public = list(
                                   initialize = function(data = NULL) {
                                       private$reactiveDep <- function(x) NULL
                                    },
                                    reactive = function() {
                                        # Ensure the reactive stuff is initialized.
                                        if (is.null(private$reactiveExpr)) {
                                            private$reactiveDep <- reactiveVal(0)
                                            private$reactiveExpr <- reactive({
                                                private$reactiveDep()
                                                self
                                            })
                                        }
                                        private$reactiveExpr
                                    },
                               ),
                               private = list(
                                   reactiveDep = NULL,
                                   reactiveExpr = NULL,
                                   invalidate = function() {
                                       private$count <- private$count + 1
                                       private$reactiveDep(private$count)
                                       invisible()
                                    },
                                    count = 0
                               )
                    )
```
The `invalidate` method can be used to invalidate the reactive class.  This is used when calling other methods that update the class contents.  Invalidating the class forces an update in the shiny app of anything that is dependent on the class instance.  In our example, the `Analysis` class contains the following reactive methods:  
**filter()**, **pca()**, **cluster()** and **set_clusters()**  
and the following non-reactive methods:  
**import()**, **get_data()** and **print()**.
